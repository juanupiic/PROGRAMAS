# -*- coding: utf-8 -*-
"""Algoritmo _MinMax_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13LQgCuo32GjLebP3HLi6mqaEtKqiogyx

NOMBRE: LUIS FERNANDO GALEANO MARTINEZ
Materia: Fundamentos de inteligencia artificial
Introducción: El código proporcionado extiende el juego de tic-tac-toe anterior, mejorando la inteligencia artificial mediante el algoritmo de poda alfa-beta. Este algoritmo optimiza la búsqueda minimax, reduciendo el número de nodos evaluados, y es aplicado en la función alphabeta para la toma de decisiones de la IA.

Conclusiones: La función alphabeta implementa el algoritmo de poda alfa-beta, una mejora del algoritmo minimax. La poda alfa-beta permite evitar explorar ramas que no afectarán la decisión final, mejorando la eficiencia computacional.
La función mejor_movimiento utiliza el algoritmo alphabeta para determinar el mejor movimiento posible para el jugador "X". Al igual que en el código anterior, se exploran todas las opciones y se selecciona el movimiento que maximiza la probabilidad de ganar.

Bibliografía: Russell, S., & Norvig, P. (2010). Artificial Intelligence: A Modern Approach (3rd ed.). Pearson.
ECHO POR EL EQUIPO DE: LUIS FERNANDO GALEANO MARTINEZ  Y JUAN MANUEL GALINDO CORTES
"""

import math

def imprimir_tablero(tablero):
    for fila in tablero:
        print(" ".join(fila))
    print()

def es_tablero_lleno(tablero):
    for fila in tablero:
        if " " in fila:
            return False
    return True

def evaluar_estado(tablero):
    # Evaluación simple para el tic-tac-toe
    ganador = None
    # Filas
    for fila in tablero:
        if fila.count("X") == 3:
            ganador = "X"
        elif fila.count("O") == 3:
            ganador = "O"
    # Columnas
    for col in range(3):
        if tablero[0][col] == tablero[1][col] == tablero[2][col] and tablero[0][col] != " ":
            ganador = tablero[0][col]
    # Diagonales
    if tablero[0][0] == tablero[1][1] == tablero[2][2] and tablero[0][0] != " ":
        ganador = tablero[0][0]
    if tablero[0][2] == tablero[1][1] == tablero[2][0] and tablero[0][2] != " ":
        ganador = tablero[0][2]

    if ganador == "X":
        return 1
    elif ganador == "O":
        return -1
    elif es_tablero_lleno(tablero):
        return 0
    else:
        return None

def alphabeta(tablero, profundidad, alfa, beta, es_maximizando):
    estado_actual = evaluar_estado(tablero)

    if estado_actual is not None:
        return estado_actual

    if es_maximizando:
        mejor_valor = -math.inf
        for i in range(3):
            for j in range(3):
                if tablero[i][j] == " ":
                    tablero[i][j] = "X"
                    valor = alphabeta(tablero, profundidad + 1, alfa, beta, False)
                    tablero[i][j] = " "
                    mejor_valor = max(mejor_valor, valor)
                    alfa = max(alfa, mejor_valor)
                    if beta <= alfa:
                        break
        return mejor_valor
    else:
        mejor_valor = math.inf
        for i in range(3):
            for j in range(3):
                if tablero[i][j] == " ":
                    tablero[i][j] = "O"
                    valor = alphabeta(tablero, profundidad + 1, alfa, beta, True)
                    tablero[i][j] = " "
                    mejor_valor = min(mejor_valor, valor)
                    beta = min(beta, mejor_valor)
                    if beta <= alfa:
                        break
        return mejor_valor

def mejor_movimiento(tablero):
    mejor_valor = -math.inf
    mejor_mov = None
    alfa = -math.inf
    beta = math.inf

    for i in range(3):
        for j in range(3):
            if tablero[i][j] == " ":
                tablero[i][j] = "X"
                valor = alphabeta(tablero, 0, alfa, beta, False)
                tablero[i][j] = " "

                if valor > mejor_valor:
                    mejor_valor = valor
                    mejor_mov = (i, j)
                alfa = max(alfa, mejor_valor)

    return mejor_mov

# Ejemplo de uso con tic-tac-toe
tablero_inicial = [
    [" ", " ", " "],
    [" ", " ", " "],
    [" ", " ", " "]
]

turno = "X"

while evaluar_estado(tablero_inicial) is None and not es_tablero_lleno(tablero_inicial):
    imprimir_tablero(tablero_inicial)

    if turno == "X":
        fila, col = map(int, input("Turno de X. Ingrese fila y columna (separadas por espacio): ").split())
        if tablero_inicial[fila][col] == " ":
            tablero_inicial[fila][col] = "X"
        else:
            print("Casilla ocupada. Intenta de nuevo.")
            continue
    else:
        print("Turno de O (IA)")
        movimiento = mejor_movimiento(tablero_inicial)
        fila, col = movimiento
        tablero_inicial[fila][col] = "O"

    turno = "O" if turno == "X" else "X"

imprimir_tablero(tablero_inicial)
resultado = evaluar_estado(tablero_inicial)

if resultado == 1:
    print("¡X gana!")
elif resultado == -1:
    print("¡O gana!")
else:
    print("¡Empate!")

import numpy as np
import matplotlib.pyplot as plt

# Definición del laberinto de ejemplo
laberinto = np.array([
    [0, 0, 0, 0, 0],
    [0, 1, 1, 1, 0],
    [0, 1, 0, 1, 0],
    [0, 1, 1, 1, 0],
    [0, 0, 0, 0, 0]
])

inicio = (0, 0)
meta = (4, 4)

# Función para visualizar el laberinto y la ruta encontrada
def visualizar_laberinto_ruta(laberinto, ruta=None):
    plt.imshow(laberinto, cmap='gray', interpolation='none', origin='upper')

    if ruta:
        ruta_x = [p[1] for p in ruta]
        ruta_y = [p[0] for p in ruta]
        plt.plot(ruta_x, ruta_y, marker='o', color='red')

    plt.title('Laberinto')
    plt.show()

# Función para realizar un movimiento en el laberinto
def realizar_movimiento(posicion_actual, direccion):
    nueva_posicion = (posicion_actual[0] + direccion[0], posicion_actual[1] + direccion[1])
    return nueva_posicion

# Función para verificar si un movimiento es válido
def es_movimiento_valido(posicion, laberinto):
    return 0 <= posicion[0] < laberinto.shape[0] and 0 <= posicion[1] < laberinto.shape[1] and laberinto[posicion[0], posicion[1]] == 0

# Función para el juego entre dos jugadores humanos
def juego_dos_jugadores(laberinto, inicio, meta):
    posicion_actual = inicio
    ruta_jugador1 = [posicion_actual]
    ruta_jugador2 = []

    while posicion_actual != meta:
        visualizar_laberinto_ruta(laberinto, ruta_jugador1 + ruta_jugador2)

        # Turno del Jugador 1
        direccion_jugador1 = tuple(map(int, input("Turno del Jugador 1. Ingrese dirección (fila columna): ").split()))
        nueva_posicion_jugador1 = realizar_movimiento(posicion_actual, direccion_jugador1)

        if es_movimiento_valido(nueva_posicion_jugador1, laberinto):
            ruta_jugador1.append(nueva_posicion_jugador1)
            posicion_actual = nueva_posicion_jugador1
        else:
            print("Movimiento no válido. Inténtalo de nuevo.")
            continue

        if posicion_actual == meta:
            print("¡Jugador 1 ha llegado a la meta!")
            break

        visualizar_laberinto_ruta(laberinto, ruta_jugador1 + ruta_jugador2)

        # Turno del Jugador 2
        direccion_jugador2 = tuple(map(int, input("Turno del Jugador 2. Ingrese dirección (fila columna): ").split()))
        nueva_posicion_jugador2 = realizar_movimiento(posicion_actual, direccion_jugador2)

        if es_movimiento_valido(nueva_posicion_jugador2, laberinto):
            ruta_jugador2.append(nueva_posicion_jugador2)
            posicion_actual = nueva_posicion_jugador2
        else:
            print("Movimiento no válido. Inténtalo de nuevo.")
            continue

    print("¡Juego terminado!")

# Iniciar juego entre dos jugadores humanos
juego_dos_jugadores(laberinto, inicio, meta)