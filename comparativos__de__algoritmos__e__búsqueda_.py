# -*- coding: utf-8 -*-
"""Comparativos _de_ algoritmos_ e_ búsqueda_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16mXqI2qgq0jBdyNlQD7Gc0U6yj2B3lnF

NOMBRE: Juan Manuel Galindo Cortes
MATERIA:Fundamentos de inteligencia artificial
Introducción:
Este código implementa dos algoritmos de búsqueda, A* y Búsqueda Voraz, para encontrar la ruta óptima en un laberinto. El laberinto se representa como una matriz binaria, donde 0 indica un espacio libre y 1 representa una pared.
Conclusiones
A vs. Búsqueda Voraz:* La comparación de tiempos de ejecución muestra que, en promedio, A* tiende a ser más lento que la Búsqueda Voraz. Esto se debe a la naturaleza más compleja de A*, que tiene en cuenta tanto el costo acumulado como la heurística. Sin embargo, la elección del algoritmo depende de varios factores, incluida la complejidad del laberinto y la necesidad de encontrar la ruta más corta.
Heurística de Distancia Manhattan: La elección de la heurística de distancia Manhattan es adecuada para este tipo de laberinto, donde los movimientos solo se permiten en cuatro direcciones. Otras heurísticas podrían ser más apropiadas para laberintos con restricciones y características específicas.
Bibliografía
Russel, S., & Norvig, P. (2009). Artificial Intelligence: A Modern Approach. Prentice Hall.
"""

import time
import matplotlib.pyplot as plt
import numpy as np
import heapq

# Definición del laberinto de ejemplo
laberinto = np.array([
    [0, 0, 0, 0, 0],
    [0, 1, 1, 1, 0],
    [0, 1, 0, 1, 0],
    [0, 1, 1, 1, 0],
    [0, 0, 0, 0, 0]
])

inicio = (0, 0)
meta = (4, 4)

# Función de heurística (distancia Manhattan)
def heuristica(pos_actual, meta):
    return abs(pos_actual[0] - meta[0]) + abs(pos_actual[1] - meta[1])

# Algoritmo de A*
def a_estrella(laberinto, inicio, meta):
    frontera = [(0, inicio, [])]
    explorado = set()

    while frontera:
        costo, actual, ruta = heapq.heappop(frontera)

        if actual == meta:
            return ruta + [meta]

        if actual not in explorado:
            explorado.add(actual)
            vecinos = [(actual[0] + 1, actual[1]),
                       (actual[0] - 1, actual[1]),
                       (actual[0], actual[1] + 1),
                       (actual[0], actual[1] - 1)]

            for vecino in vecinos:
                if 0 <= vecino[0] < laberinto.shape[0] and 0 <= vecino[1] < laberinto.shape[1] and laberinto[vecino[0], vecino[1]] == 0:
                    nuevo_costo = costo + 1
                    heur = heuristica(vecino, meta)
                    heapq.heappush(frontera, (nuevo_costo + heur, vecino, ruta + [actual]))

# Algoritmo de búsqueda voraz (Greedy)
def busqueda_voraz(laberinto, inicio, meta):
    frontera = [(heuristica(inicio, meta), inicio, [])]
    explorado = set()

    while frontera:
        _, actual, ruta = heapq.heappop(frontera)

        if actual == meta:
            return ruta + [meta]

        if actual not in explorado:
            explorado.add(actual)
            vecinos = [(actual[0] + 1, actual[1]),
                       (actual[0] - 1, actual[1]),
                       (actual[0], actual[1] + 1),
                       (actual[0], actual[1] - 1)]

            for vecino in vecinos:
                if 0 <= vecino[0] < laberinto.shape[0] and 0 <= vecino[1] < laberinto.shape[1] and laberinto[vecino[0], vecino[1]] == 0:
                    heur = heuristica(vecino, meta)
                    heapq.heappush(frontera, (heur, vecino, ruta + [actual]))

# Función para visualizar el laberinto y la ruta encontrada
def visualizar_laberinto_ruta(laberinto, ruta, algoritmo):
    plt.imshow(laberinto, cmap='gray', interpolation='none', origin='upper')
    plt.title(f'Laberinto con Ruta ({algoritmo})')

    ruta_x = [p[1] for p in ruta]
    ruta_y = [p[0] for p in ruta]
    plt.plot(ruta_x, ruta_y, marker='o', color='red')

    plt.show()

# Aplicar algoritmo A*
ruta_a_estrella = a_estrella(laberinto, inicio, meta)
visualizar_laberinto_ruta(laberinto, ruta_a_estrella, 'A*')

# Aplicar búsqueda voraz
ruta_voraz = busqueda_voraz(laberinto, inicio, meta)
visualizar_laberinto_ruta(laberinto, ruta_voraz, 'Búsqueda Voraz')




# Función para medir el tiempo de ejecución de un algoritmo
def medir_tiempo(algoritmo, *args):
    inicio_tiempo = time.time()
    algoritmo(*args)
    fin_tiempo = time.time()
    return fin_tiempo - inicio_tiempo

# Comparación de tiempos
n_experimentos = 10  # Puedes ajustar el número de experimentos
tiempos_a_estrella = []
tiempos_voraz = []

for _ in range(n_experimentos):
    tiempo_a_estrella = medir_tiempo(a_estrella, laberinto, inicio, meta)
    tiempos_a_estrella.append(tiempo_a_estrella)

    tiempo_voraz = medir_tiempo(busqueda_voraz, laberinto, inicio, meta)
    tiempos_voraz.append(tiempo_voraz)

# Gráfico de comparación
etiquetas = ['A*', 'Búsqueda Voraz']
tiempos_promedio = [np.mean(tiempos_a_estrella), np.mean(tiempos_voraz)]

plt.bar(etiquetas, tiempos_promedio, color=['blue', 'orange'])
plt.ylabel('Tiempo Promedio (s)')
plt.title('Comparación de Tiempos de Ejecución')
plt.show()

"""Algoritmos sin retorno: Ambos algoritmos, a_estrella y busqueda_voraz, no tienen una instrucción return fuera de sus bucles while. Deberías añadir una instrucción return al final de cada función que devuelva la ruta encontrada."""

return ruta_a_estrella
return ruta_voraz

"""Experimentos y número de experimentos: Estás realizando un número fijo de experimentos (n_experimentos = 10). Puedes ajustar este número según tus necesidades. Cuanto mayor sea el número de experimentos, más precisa será la medición del tiempo promedio, pero también llevará más tiempo ejecutar el código.

Función de heurística: La función de heurística utilizada es la distancia de Manhattan, que es apropiada para este tipo de laberinto. Si estás experimentando con diferentes tipos de laberintos, podrías considerar ajustar la función de heurística según las características del laberinto.

Visualización de la ruta: La visualización de la ruta en el laberinto es útil para entender cómo se está moviendo el algoritmo. Ten en cuenta que la visualización puede no ser adecuada para laberintos muy grandes debido a la densidad de nodos.

Comparación de tiempos: La comparación de tiempos se realiza mediante la función medir_tiempo y se muestra en un gráfico de barras al final del código. Este gráfico representa el tiempo promedio de ejecución para cada algoritmo.
"""